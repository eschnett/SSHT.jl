<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SSHT.jl: Fast and exact spin spherical harmonic transforms · SSHT</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SSHT</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SSHT.jl: Fast and exact spin spherical harmonic transforms</a><ul class="internal"><li><a class="tocitem" href="#Spin-weighted-Spherical-Harmonic-transforms"><span>Spin-weighted Spherical Harmonic transforms</span></a></li><li><a class="tocitem" href="#Derivatives-ð-(eth)-and-ð-(eth-bar)"><span>Derivatives ð (eth) and ð̄ (eth-bar)</span></a></li><li><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SSHT.jl: Fast and exact spin spherical harmonic transforms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SSHT.jl: Fast and exact spin spherical harmonic transforms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/eschnett/SSHT.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SSHT.jl:-Fast-and-exact-spin-spherical-harmonic-transforms"><a class="docs-heading-anchor" href="#SSHT.jl:-Fast-and-exact-spin-spherical-harmonic-transforms">SSHT.jl: Fast and exact spin spherical harmonic transforms</a><a id="SSHT.jl:-Fast-and-exact-spin-spherical-harmonic-transforms-1"></a><a class="docs-heading-anchor-permalink" href="#SSHT.jl:-Fast-and-exact-spin-spherical-harmonic-transforms" title="Permalink"></a></h1><p>This package is a Julia wrapper for the <a href="https://astro-informatics.github.io/ssht/">SSHT</a> library. It calculates spin spherical harmonic transforms.</p><p>Most functions come in two versions, one that mutates its arguments and one that allocates its output.</p><h2 id="Spin-weighted-Spherical-Harmonic-transforms"><a class="docs-heading-anchor" href="#Spin-weighted-Spherical-Harmonic-transforms">Spin-weighted Spherical Harmonic transforms</a><a id="Spin-weighted-Spherical-Harmonic-transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-weighted-Spherical-Harmonic-transforms" title="Permalink"></a></h2><p>The functions with <code>dh</code> in their names use the Driscoll &amp; Healy quadrature points. With <code>L = lmax+1</code> modes there are <code>nphi * ntheta</code> quadrature points on the sphere, with <code>nphi = 2L-1</code> and <code>ntheta = 2L</code>. The points are equispaced in the angles <code>theta</code> (latitude) and <code>phi</code> (longitude), and they straddle (avoid) the poles.</p><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_inverse_sov!" href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SSHT.core_dh_inverse_sov!(f::AbstractArray{Complex{Float64},2},
                          flm::AbstractVector{Complex{Float64}},
                          L::Integer,
                          spin::Integer,
                          verbosity::Integer=0)</code></pre><p>Evaluate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>.</p><p>The arrays <code>flm</code> and <code>f</code> must have the following sizes:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
length(flm) == L^2
size(f) == (nphi, ntheta)</code></pre><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_inverse_sov"><code>SSHT.core_dh_inverse_sov</code></a>, <a href="#SSHT.core_dh_inverse_sov_real!"><code>SSHT.core_dh_inverse_sov_real!</code></a>, <a href="#SSHT.core_dh_forward_sov!"><code>SSHT.core_dh_forward_sov!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L12-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_inverse_sov" href="#SSHT.core_dh_inverse_sov"><code>SSHT.core_dh_inverse_sov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f = SSHT.core_dh_inverse_sov(flm::AbstractVector{Complex{Float64}},
                             L::Integer,
                             spin::Integer,
                             verbosity::Integer=0)
f::Array{Complex{Float64},2}</code></pre><p>Evaluate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>.</p><p>The array <code>flm</code> must have the length <code>L^2</code>. The result <code>f</code> will have the following size:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
size(f) == (nphi, ntheta)</code></pre><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>, <a href="#SSHT.core_dh_inverse_sov_real"><code>SSHT.core_dh_inverse_sov_real</code></a>, <a href="#SSHT.core_dh_forward_sov"><code>SSHT.core_dh_forward_sov</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L48-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_inverse_sov_real!" href="#SSHT.core_dh_inverse_sov_real!"><code>SSHT.core_dh_inverse_sov_real!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SSHT.core_dh_inverse_sov_real!(f::AbstractArray{Float64,2},
                               flm::AbstractVector{Complex{Float64}},
                               L::Integer,
                               spin::Integer,
                               verbosity::Integer=0)</code></pre><p>Evaluate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>. The result <code>f</code> is real-valued.</p><p>The arrays <code>flm</code> and <code>f</code> must have the following sizes:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
length(flm) == L^2
size(f) == (nphi, ntheta)</code></pre><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_inverse_sov_real"><code>SSHT.core_dh_inverse_sov_real</code></a>, <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>, <a href="#SSHT.core_dh_forward_sov_real!"><code>SSHT.core_dh_forward_sov_real!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L81-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_inverse_sov_real" href="#SSHT.core_dh_inverse_sov_real"><code>SSHT.core_dh_inverse_sov_real</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f = SSHT.core_dh_inverse_sov_real(flm::AbstractVector{Complex{Float64}},
                                  L::Integer,
                                  spin::Integer,
                                  verbosity::Integer=0)
f::Array{Float64,2}</code></pre><p>Evaluate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>. The result <code>f</code> is real-valued.</p><p>The array <code>flm</code> must have the length <code>L^2</code>. The result <code>f</code> will have the following size:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
size(f) == (nphi, ntheta)</code></pre><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_inverse_sov_real!"><code>SSHT.core_dh_inverse_sov_real!</code></a>, <a href="#SSHT.core_dh_inverse_sov"><code>SSHT.core_dh_inverse_sov</code></a>, <a href="#SSHT.core_dh_forward_sov_real"><code>SSHT.core_dh_forward_sov_real</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L118-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_forward_sov!" href="#SSHT.core_dh_forward_sov!"><code>SSHT.core_dh_forward_sov!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SSHT.core_dh_forward_sov!(flm::AbstractVector{Complex{Float64}},
                          f::AbstractArray{Complex{Float64},2},
                          L::Integer,
                          spin::Integer,
                          verbosity::Integer=0)</code></pre><p>Calculate spin-weighted spherical harmonic coefficients with spin-weight <code>spin</code> <code>flm</code> from grid point values <code>f</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>.</p><p>The arrays <code>flm</code> and <code>f</code> must have the following sizes:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
length(flm) == L^2
size(f) == (nphi, ntheta)</code></pre><p>Use <a href="@ref"><code>SSTH.sampling_elm2ind</code></a> to access individual modes in the <code>flm</code> array.</p><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_forward_sov"><code>SSHT.core_dh_forward_sov</code></a>, <a href="#SSHT.core_dh_forward_sov_real!"><code>SSHT.core_dh_forward_sov_real!</code></a>, <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L152-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_forward_sov" href="#SSHT.core_dh_forward_sov"><code>SSHT.core_dh_forward_sov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flm = SSHT.core_dh_forward_sov(fl:AbstractVector{Complex{Float64}},
                               L::Integer,
                               spin::Integer,
                               verbosity::Integer=0)
flm::Vector{Complex{Float64}}</code></pre><p>Calculate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code> from grid point values <code>f</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>.</p><p>The array <code>flm</code> will have length <code>L^2</code>. The input <code>f</code> must have the following size:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
size(f) == (nphi, ntheta)</code></pre><p>Use <a href="@ref"><code>SSTH.sampling_elm2ind</code></a> to access individual modes in the <code>flm</code> array.</p><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_forward_sov!"><code>SSHT.core_dh_forward_sov!</code></a>, <a href="#SSHT.core_dh_forward_sov_real"><code>SSHT.core_dh_forward_sov_real</code></a>, <a href="#SSHT.core_dh_inverse_sov"><code>SSHT.core_dh_inverse_sov</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L192-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_forward_sov_real!" href="#SSHT.core_dh_forward_sov_real!"><code>SSHT.core_dh_forward_sov_real!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SSHT.core_dh_forward_sov_real!(flm::AbstractVector{Complex{Float64}},
                               f::AbstractArray{Float64,2},
                               L::Integer,
                               spin::Integer,
                               verbosity::Integer=0)</code></pre><p>Calculate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code> from real-valued grid point values <code>f</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>.</p><p>The arrays <code>flm</code> and <code>f</code> must have the following sizes:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
length(flm) == L^2
size(f) == (nphi, ntheta)</code></pre><p>Use <a href="@ref"><code>SSTH.sampling_elm2ind</code></a> to access individual modes in the <code>flm</code> array.</p><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_forward_sov_real"><code>SSHT.core_dh_forward_sov_real</code></a>, <a href="#SSHT.core_dh_forward_sov!"><code>SSHT.core_dh_forward_sov!</code></a>, <a href="#SSHT.core_dh_inverse_sov_real!"><code>SSHT.core_dh_inverse_sov_real!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L227-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.core_dh_forward_sov_real" href="#SSHT.core_dh_forward_sov_real"><code>SSHT.core_dh_forward_sov_real</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flm = SSHT.core_dh_inverse_sov_real(f::AbstractVector{Float64},
                                    L::Integer,
                                    spin::Integer,
                                    verbosity::Integer=0)
f::Array{Complex{Float64},2}</code></pre><p>Calculate spin-weighted spherical harmonic coefficients <code>flm</code> with spin-weight <code>spin</code> from real-valued grid point values <code>f</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>.</p><p>The array <code>flm</code> must have the length <code>L^2</code>. The result <code>f</code> will have the following size:</p><pre><code class="nohighlight hljs">nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
size(f) == (nphi, ntheta)</code></pre><p>Use <a href="@ref"><code>SSTH.sampling_elm2ind</code></a> to access individual modes in the <code>flm</code> array.</p><p>See the <a href="https://astro-informatics.github.io/ssht/c/html/ssht__core_8h.html">SSHT reference</a> for details.</p><p>See also: <a href="#SSHT.core_dh_forward_sov_real!"><code>SSHT.core_dh_forward_sov_real!</code></a>, <a href="#SSHT.core_dh_forward_sov"><code>SSHT.core_dh_forward_sov</code></a>, <a href="#SSHT.core_dh_inverse_sov_real"><code>SSHT.core_dh_inverse_sov_real</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L267-L295">source</a></section></article><h2 id="Derivatives-ð-(eth)-and-ð-(eth-bar)"><a class="docs-heading-anchor" href="#Derivatives-ð-(eth)-and-ð-(eth-bar)">Derivatives ð (eth) and ð̄ (eth-bar)</a><a id="Derivatives-ð-(eth)-and-ð-(eth-bar)-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives-ð-(eth)-and-ð-(eth-bar)" title="Permalink"></a></h2><p>See <a href="https://en.wikipedia.org/wiki/Spin-weighted_spherical_harmonics">Wikipedia</a> for the definition of these operators.</p><article class="docstring"><header><a class="docstring-binding" id="SSHT.eth!" href="#SSHT.eth!"><code>SSHT.eth!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eth!(ðflm::AbstractVector, flm::AbstractVector, L::Integer, spin::Integer)</code></pre><p>Calculate the <code>ð</code> (eth) derivative of the spin-weighted spherical harmonic coefficients <code>flm</code> with spin weight <code>s</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>. The result has spin weight <code>s+1</code>.</p><p>The arrays <code>ðflm</code> and <code>flm</code> must have length <code>L^2</code>.</p><p>See <a href="https://en.wikipedia.org/wiki/Spin-weighted_spherical_harmonics">Wikipedia</a> for a definition of the <code>ð</code> (eth) operator.</p><p>See also: <a href="#SSHT.eth"><code>SSHT.eth</code></a>, <a href="#SSHT.ethbar!"><code>SSHT.ethbar!</code></a>, <a href="@ref"><code>SSHT.core_dh_transform_sov!</code></a>, <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L461-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.eth" href="#SSHT.eth"><code>SSHT.eth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ðflm = eth(flm::AbstractVector, L::Integer, spin::Integer)
ðflm::AbstractVector</code></pre><p>Calculate the <code>ð</code> (eth) derivative of the spin-weighted spherical harmonic coefficients <code>flm</code> with spin weight <code>s</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>. The result has spin weight <code>s+1</code>.</p><p>The array <code>flm</code> must have length <code>L^2</code>. The result <code>ðflm</code> will also have length <code>L^2</code>.</p><p>See <a href="https://en.wikipedia.org/wiki/Spin-weighted_spherical_harmonics">Wikipedia</a> for a definition of the <code>ð</code> (eth) operator.</p><p>See also: <a href="#SSHT.eth"><code>SSHT.eth</code></a>, <a href="#SSHT.ethbar!"><code>SSHT.ethbar!</code></a>, <a href="@ref"><code>SSHT.core_dh_transform_sov!</code></a>, <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L500-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.ethbar!" href="#SSHT.ethbar!"><code>SSHT.ethbar!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ethbar!(ð̄flm::AbstractVector, flm::AbstractVector, L::Integer, spin::Integer)</code></pre><p>Calculate the <code>ð̄</code> (eth-bar) derivative of the spin-weighted spherical harmonic coefficients <code>flm</code> with spin weight <code>s</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>. The result has spin weight <code>s-1</code>.</p><p>The arrays <code>ð̄flm</code> and <code>flm</code> must have length <code>L^2</code>.</p><p>See <a href="https://en.wikipedia.org/wiki/Spin-weighted_spherical_harmonics">Wikipedia</a> for a definition of the <code>ð̄</code> (eth-bar) operator.</p><p>See also: <a href="#SSHT.ethbar"><code>SSHT.ethbar</code></a>, <a href="#SSHT.eth!"><code>SSHT.eth!</code></a>, <a href="@ref"><code>SSHT.core_dh_transform_sov!</code></a>, <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L521-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.ethbar" href="#SSHT.ethbar"><code>SSHT.ethbar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ð̄flm = ethbar(flm::AbstractVector, L::Integer, spin::Integer)
ð̄flm::AbstractVector</code></pre><p>Calculate the <code>ð̄</code> (eth) derivative of the spin-weighted spherical harmonic coefficients <code>flm</code> with spin weight <code>s</code>. <code>L = lmax+1</code> is the number of modes in <code>flm</code>. The result has spin weight <code>s-1</code>.</p><p>The array <code>flm</code> must have length <code>L^2</code>. The result <code>ð̄flm</code> will also have length <code>L^2</code>.</p><p>See <a href="https://en.wikipedia.org/wiki/Spin-weighted_spherical_harmonics">Wikipedia</a> for a definition of the <code>ð</code> (eth) operator.</p><p>See also: <a href="#SSHT.ethbar"><code>SSHT.ethbar</code></a>, <a href="#SSHT.eth!"><code>SSHT.eth!</code></a>, <a href="@ref"><code>SSHT.core_dh_transform_sov!</code></a>, <a href="#SSHT.core_dh_inverse_sov!"><code>SSHT.core_dh_inverse_sov!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L560-L578">source</a></section></article><h2 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_dh_n" href="#SSHT.sampling_dh_n"><code>SSHT.sampling_dh_n</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">n = sampling_dh_n(L::Integer)
n::Int</code></pre><p>Total number of unique collocation points for <code>L = lmax+1</code> modes that. (If the collocation scheme places points onto the poles, then not all collocation points are unique.)</p><p>See also: <a href="#SSHT.sampling_dh_nphi"><code>SSHT.sampling_dh_nphi</code></a>, <a href="#SSHT.sampling_dh_ntheta"><code>SSHT.sampling_dh_ntheta</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L318-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_dh_nphi" href="#SSHT.sampling_dh_nphi"><code>SSHT.sampling_dh_nphi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nphi = sampling_dh_nphi(L::Integer)
nphi::Int</code></pre><p>Number of collocation points in the <code>phi</code> direction for <code>L = lmax+1</code> modes.</p><p>See also: <a href="#SSHT.sampling_dh_n"><code>SSHT.sampling_dh_n</code></a>, <a href="#SSHT.sampling_dh_ntheta"><code>SSHT.sampling_dh_ntheta</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L331-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_dh_ntheta" href="#SSHT.sampling_dh_ntheta"><code>SSHT.sampling_dh_ntheta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ntheta = sampling_dh_ntheta(L::Integer)
ntheta::Int</code></pre><p>Number of collocation points in the <code>theta</code> direction for <code>L = lmax+1</code> modes.</p><p>See also: <a href="#SSHT.sampling_dh_n"><code>SSHT.sampling_dh_n</code></a>, <a href="#SSHT.sampling_dh_nphi"><code>SSHT.sampling_dh_nphi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L343-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_dh_p2phi" href="#SSHT.sampling_dh_p2phi"><code>SSHT.sampling_dh_p2phi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phi = sampling_dh_p2phi(p::Integer, L::Integer)
phi::Float64</code></pre><p>Calculate the <code>phi</code> coordinate for point <code>p</code> in the <code>phi</code> direction (<code>1 ≤ p ≤ nphi</code>).</p><p>See also: <a href="#SSHT.sampling_dh_t2theta"><code>SSHT.sampling_dh_t2theta</code></a>, <a href="#SSHT.sampling_dh_nphi"><code>SSHT.sampling_dh_nphi</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L355-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_dh_t2theta" href="#SSHT.sampling_dh_t2theta"><code>SSHT.sampling_dh_t2theta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">theta = sampling_dh_p2theta(t::Integer, L::Integer)
theta::Float64</code></pre><p>Calculate the <code>theta</code> coordinate for point <code>t</code> in the <code>theta</code> direction (<code>1 ≤ t ≤ ntheta</code>).</p><p>See also: <a href="#SSHT.sampling_dh_p2phi"><code>SSHT.sampling_dh_p2phi</code></a>, <a href="#SSHT.sampling_dh_ntheta"><code>SSHT.sampling_dh_ntheta</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L367-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_weight_dh" href="#SSHT.sampling_weight_dh"><code>SSHT.sampling_weight_dh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">w = sampling_weight_dh(theta_t::Real, L::Integer)
w::Float64</code></pre><p>Calculate the sampling weight of a point with the given <code>theta</code> coordinate. This value is essentially <code>sin(theta) * dtheta</code>, possibly modified to achive higher accuracy depending on how the collocation points are spaced out in the <code>theta</code> direction.</p><p>Integrating a function over the sphere should be done as follows:</p><pre><code class="nohighlight hljs"># Input: Choose `L` and array `f`
s = 0.0
nphi = SSHT.sampling_dh_nphi(L)
ntheta = SSHT.sampling_dh_ntheta(L)
for p in 1:nphi, t in 1:ntheta
    phi = SSHT.sampling_dh_p2phi(p, L)
    theta = SSHT.sampling_dh_t2theta(t, L)
    # dtheta = π / ntheta
    dtheta = SSHT.sampling_weight_dh(theta, L)
    dphi = 2π / nphi
    s += f[p, t] * dtheta * dphi
end
# Output: s</code></pre><p>See also: <a href="#SSHT.sampling_dh_nphi"><code>SSHT.sampling_dh_nphi</code></a>, <a href="#SSHT.sampling_dh_ntheta"><code>SSHT.sampling_dh_ntheta</code></a>, <a href="#SSHT.sampling_dh_p2phi"><code>SSHT.sampling_dh_p2phi</code></a>, <a href="#SSHT.sampling_dh_t2theta"><code>SSHT.sampling_dh_t2theta</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L379-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_elm2ind" href="#SSHT.sampling_elm2ind"><code>SSHT.sampling_elm2ind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ind = sampling_elm2ind(el::Integer, m::Integer)
ind::Int</code></pre><p>Calculate the mode array index <code>ind</code> for a given mode <code>l</code>, <code>m</code>. For <code>L = lmax+1</code> modes, there are <code>L^2</code> modes in total.</p><p>See also: <a href="#SSHT.sampling_ind2elm"><code>sampling_ind2elm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L421-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SSHT.sampling_ind2elm" href="#SSHT.sampling_ind2elm"><code>SSHT.sampling_ind2elm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">l, m = sampling_ind2elm(ind::Integer)
l::Int
m::Int</code></pre><p>Calculate the mode numbers <code>l</code> and <code>m</code> from a given mode array index <code>ind</code>. For <code>L = lmax+1</code> modes, there are <code>L^2</code> modes in total: <code>1 ≤ ind ≤ L^2</code>.</p><p>This function needs to evaluate a square root internally. If possible, using <a href="#SSHT.sampling_elm2ind"><code>sampling_elm2ind</code></a> instead is slightly preferred.</p><p>See also: <a href="#SSHT.sampling_elm2ind"><code>sampling_elm2ind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/eschnett/SSHT.jl/blob/c7a55b640533a72a1317f72dc7dfd1d68e174733/src/SSHT.jl#L437-L450">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 7 February 2022 19:58">Monday 7 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
